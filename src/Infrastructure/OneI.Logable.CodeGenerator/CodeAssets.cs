namespace OneI.Logable;

internal static class CodeAssets
{
    public const string LogableNamespace = $"OneI.{Logable}";
    public const string Logable          = "Logable";
    public const string LoggerFullName   = $"{LogableNamespace}.ILogger";

    public const string LogClassFullName      = $"{LogableNamespace}.Log";
    public const string LogExtensionsFileName = "Log.e.g.cs";
    public const string LogFileName           = "Log.g.cs";

    public const string LogFileContent = """
        // <auto-generated/>
        #nullable enable
        namespace OneI.Logable;

        using System;
        using System.Runtime.CompilerServices;
        using OneI.Logable.Templates;

        [global::System.Diagnostics.DebuggerStepThrough]
        public static partial class Log
        {
            public static ILogger Logger = NoneLogger.Instance;

            public static void Initialize(ILogger logger)
            {
                Logger = logger ?? throw new ArgumentNullException(nameof(logger));
            }

            public static void Initialize(Action<ILoggerConfiguration> configure)
            {
                var configuration = new LoggerConfiguration();

                configure?.Invoke(configuration);

                Logger = configuration.CreateLogger();
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static bool IsEnable(LogLevel logLevel)
            {
                return Logger.IsEnable(logLevel);
            }

            #region Write

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static void Write(LogLevel level, string message, [CallerFilePath] string? file = null, [CallerMemberName] string? member = null, [CallerLineNumber] int line = 0)
            {
                var properties = new PropertyDictionary();

                LoggerExtensions.WriteCore(Logger, level, null, message, ref properties, file, member, line);

                properties.Dispose();
            }

            [Conditional("DEBUG")]
            public static void Write(LogLevel level, string message, params object?[] args)
            {
                throw new NotSupportedException();
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static void Write(LogLevel level, Exception exception, string message, [CallerFilePath] string? file = null, [CallerMemberName] string? member = null, [CallerLineNumber] int line = 0)
            {
                var properties = new PropertyDictionary();

                LoggerExtensions.WriteCore(Logger, level, exception, message, ref properties, file, member, line);

                properties.Dispose();
            }

            [Conditional("DEBUG")]
            public static void Write(LogLevel level, Exception exception, string message, params object?[] args)
            {
                throw new NotSupportedException();
            }

            #endregion Write

            #region Verbose

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static void Verbose(string message, [CallerFilePath] string? file = null, [CallerMemberName] string? member = null, [CallerLineNumber] int line = 0)
            {
                var properties = new PropertyDictionary();

                LoggerExtensions.WriteCore(Logger, LogLevel.Verbose, null, message, ref properties, file, member, line);

                properties.Dispose();
            }

            [Conditional("DEBUG")]
            public static void Verbose(string message, params object?[] args)
            {
                throw new NotSupportedException();
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static void Verbose(Exception exception, string message, [CallerFilePath] string? file = null, [CallerMemberName] string? member = null, [CallerLineNumber] int line = 0)
            {
                var properties = new PropertyDictionary();

                LoggerExtensions.WriteCore(Logger, LogLevel.Verbose, exception, message, ref properties, file, member, line);

                properties.Dispose();
            }

            [Conditional("DEBUG")]
            public static void Verbose(Exception exception, string message, params object?[] args)
            {
                throw new NotSupportedException();
            }

            #endregion Verbose

            #region Debug

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static void Debug(string message, [CallerFilePath] string? file = null, [CallerMemberName] string? member = null, [CallerLineNumber] int line = 0)
            {
                var properties = new PropertyDictionary();

                LoggerExtensions.WriteCore(Logger, LogLevel.Debug, null, message, ref properties, file, member, line);

                properties.Dispose();
            }

            [Conditional("DEBUG")]
            public static void Debug(string message, params object?[] args)
            {
                throw new NotSupportedException();
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static void Debug(Exception exception, string message, [CallerFilePath] string? file = null, [CallerMemberName] string? member = null, [CallerLineNumber] int line = 0)
            {
                var properties = new PropertyDictionary();

                LoggerExtensions.WriteCore(Logger, LogLevel.Debug, exception, message, ref properties, file, member, line);

                properties.Dispose();
            }

            [Conditional("DEBUG")]
            public static void Debug(Exception exception, string message, params object?[] args)
            {
                throw new NotSupportedException();
            }

            #endregion Debug

            #region Information

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static void Information(string message, [CallerFilePath] string? file = null, [CallerMemberName] string? member = null, [CallerLineNumber] int line = 0)
            {
                var properties = new PropertyDictionary();

                LoggerExtensions.WriteCore(Logger, LogLevel.Information, null, message, ref properties, file, member, line);

                properties.Dispose();
            }

            [Conditional("DEBUG")]
            public static void Information(string message, params object?[] args)
            {
                throw new NotSupportedException();
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static void Information(Exception exception, string message, [CallerFilePath] string? file = null, [CallerMemberName] string? member = null, [CallerLineNumber] int line = 0)
            {
                var properties = new PropertyDictionary();

                LoggerExtensions.WriteCore(Logger, LogLevel.Information, exception, message, ref properties, file, member, line);

                properties.Dispose();
            }

            [Conditional("DEBUG")]
            public static void Information(Exception exception, string message, params object?[] args)
            {
                throw new NotSupportedException();
            }

            #endregion Information

            #region Warning

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static void Warning(string message, [CallerFilePath] string? file = null, [CallerMemberName] string? member = null, [CallerLineNumber] int line = 0)
            {
                var properties = new PropertyDictionary();

                LoggerExtensions.WriteCore(Logger, LogLevel.Warning, null, message, ref properties, file, member, line);

                properties.Dispose();
            }

            [Conditional("DEBUG")]
            public static void Warning(string message, params object?[] args)
            {
                throw new NotSupportedException();
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static void Warning(Exception exception, string message, [CallerFilePath] string? file = null, [CallerMemberName] string? member = null, [CallerLineNumber] int line = 0)
            {
                var properties = new PropertyDictionary();

                LoggerExtensions.WriteCore(Logger, LogLevel.Warning, exception, message, ref properties, file, member, line);

                properties.Dispose();
            }

            [Conditional("DEBUG")]
            public static void Warning(Exception exception, string message, params object?[] args)
            {
                throw new NotSupportedException();
            }

            #endregion Warning

            #region Error

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static void Error(string message, [CallerFilePath] string? file = null, [CallerMemberName] string? member = null, [CallerLineNumber] int line = 0)
            {
                var properties = new PropertyDictionary();

                LoggerExtensions.WriteCore(Logger, LogLevel.Error, null, message, ref properties, file, member, line);

                properties.Dispose();
            }

            [Conditional("DEBUG")]
            public static void Error(string message, params object?[] args)
            {
                throw new NotSupportedException();
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static void Error(Exception exception, string message, [CallerFilePath] string? file = null, [CallerMemberName] string? member = null, [CallerLineNumber] int line = 0)
            {
                var properties = new PropertyDictionary();

                LoggerExtensions.WriteCore(Logger, LogLevel.Error, exception, message, ref properties, file, member, line);

                properties.Dispose();
            }

            [Conditional("DEBUG")]
            public static void Error(Exception exception, string message, params object?[] args)
            {
                throw new NotSupportedException();
            }

            #endregion Error

            #region Fatal

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static void Fatal(string message, [CallerFilePath] string? file = null, [CallerMemberName] string? member = null, [CallerLineNumber] int line = 0)
            {
                var properties = new PropertyDictionary();

                LoggerExtensions.WriteCore(Logger, LogLevel.Fatal, null, message, ref properties, file, member, line);

                properties.Dispose();
            }

            [Conditional("DEBUG")]
            public static void Fatal(string message, params object?[] args)
            {
                throw new NotSupportedException();
            }

            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static void Fatal(Exception exception, string message, [CallerFilePath] string? file = null, [CallerMemberName] string? member = null, [CallerLineNumber] int line = 0)
            {
                var properties = new PropertyDictionary();

                LoggerExtensions.WriteCore(Logger, LogLevel.Fatal, exception, message, ref properties, file, member, line);

                properties.Dispose();
            }

            [Conditional("DEBUG")]
            public static void Fatal(Exception exception, string message, params object?[] args)
            {
                throw new NotSupportedException();
            }

            #endregion Fatal
        }
        #nullable restore
        
        """;

    public const string LoggerPropertyCreatorClassName     = "LoggerPropertyCreator";
    public const string LoggerPropertyCreatorClassFileName = $"{Logable}.p.g.cs";
    public const string LoggerPropertyCreateMethodName     = "Create";

    public const string LoggerPropertyCreateCalledName
        = $"{LoggerPropertyCreatorClassName}.{LoggerPropertyCreateMethodName}";

    public const string MessageParameterName   = "message";
    public const string MessageParameterType   = "global::System.String";
    public const string LogLevelParameterName  = "level";
    public const string LogLevelParameterType  = $"global::{LogableNamespace}.LogLevel";
    public const string ExceptionParameterName = "exception";
    public const string ExceptionParameterType = "global::System.Exception";

    public const string LoggerExtensionClassName              = "LogableExtensions";
    public const string LoggerExtensionFullName               = $"{LogableNamespace}.LoggerExtensions";
    public const string LoggerExtensionExtensionClassFileName = $"{Logable}.e.g.cs";
}
